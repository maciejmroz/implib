/*
 * Created by Maciej Mróz
 * Copyright (C) 2005 Maciej Mróz, All Rights Reserved.
 */


#ifndef _IMP_LIB_HW_H_
#define _IMP_LIB_HW_H_

namespace NIMPLib
{
	namespace NIMPLibHwInternal
	{
		struct Layer
		{
			LayerDesc				desc;
			PDIRECT3DTEXTURE9		tx;
		};

		//rendertargets aren't lockable - so we need sysmem surface
		//that matches rt size and format
		//vidmem->sysmem is handled by IDirect3DDevice9::GetRenderTargetData()
		//sysmem->vidmem is handled by IDirect3DDevice9::UpdateSurface()
		//proxy objects exist per size class rather than per texture
		struct LayerProxy
		{
			PDIRECT3DSURFACE9		proxy_surface;
		};

		//tracks changes to constant table, allows for commiting only changed value
		//set to hardware
		class ConstantTable : private boost::noncopyable
		{
			float		*tbl;
		public:
			const int	size;

			ConstantTable(int size_p) :
			size(size_p)
			{
				tbl=new float[4*size];
			}

			~ConstantTable()
			{
				delete [] tbl;
				tbl=NULL;
			}

			inline float* get_constant_vec(int first_index,int vsize)
			{
				assert(first_index>=0);
				assert(first_index+vsize<=size);
				return &tbl[first_index];
			}
		};

		//loads and caches shaders from libraries generated by mkshlib.py
		class ShaderDrv : private boost::noncopyable
		{
			typedef std::map<int,PDIRECT3DPIXELSHADER9>				ps_lib_internal_map_t;
			typedef std::map<std::wstring,lib_ps_internal_map_t>	ps_lib_map_t;
			ps_lib_map_t			loaded_shaders;
			PDIRECT3DDEVICE9		device;
			PDIRECT3DPIXELSHADER9	current_shader;
		public:
			ShaderDrv() :
			device(NULL),
			current_shader(NULL)
			{
			}

			~ShaderDrv()
			{
				release_all();
			}

			void set_device(PDIRECT3DDEVICE9 dev)
			{
				device=dev;
			}

			void release_all()
			{
				ps_lib_map_t::iterator outer_it=loaded_shaders.begin();
				while(outer_it!=loaded_shaders.end())
				{
					ps_lib_internal_map_t &psm=(*outer_it);
					ps_lib_internal_map_t::iterator inner_t=psm.begin();
					while(inner_it!=psm.end())
					{
						(*inner_it).second->Release();
						(*inner_it).second=NULL;
						inner_it++;
					}
					psm.clear();
					outer_it++;
				}
				loaded_shaders.clear();
			}

			PDIRECT3DPIXELSHADER9 load_pixel_shader(const std::wstring &lib_name,int index);
			void set_shader(PDIRECT3DPIXELSHADER9 sh,ConstantTable &ct);
		};

		struct shader_base
		{
			PDIRECT3DPIXELSHADER9	shader;
			ID3DXConstantTable		*constant_table;
			bool init(const TCHAR *shader_file,
				PDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				LPD3DXBUFFER shader_buffer=NULL;
				if(FAILED(D3DXCompileShaderFromFile(shader_file,NULL,NULL,"main",
					profile,0,&shader_buffer,NULL,&constant_table)))
				{
					assert(false);
					return false;
				}
				if(FAILED(dev->CreatePixelShader(
					(DWORD*)shader_buffer->GetBufferPointer(),
					&shader)))
				{
					shader_buffer->Release();
					assert(false);
					return false;
				}
				shader_buffer->Release();
				return true;
			}
			void setup(PDIRECT3DDEVICE9 dev)
			{
				dev->SetPixelShader(shader);
			}
			void release()
			{
				if(shader)
				{
					shader->Release();
				}
				if(constant_table)
				{
					constant_table->Release();
				}
			}
		};

		struct shader_C1 : public shader_base
		{
			D3DXHANDLE			c1_handle;

			float				c1[4];

			bool init(const TCHAR *shader_file,
				LPDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				if(!shader_base::init(shader_file,dev,profile))
				{
					return false;
				}
				//c1
				c1_handle=NULL;
				c1_handle=constant_table->GetConstantByName(NULL,"c1");
				assert(c1_handle);
				return true;
			}
			void setup(PDIRECT3DDEVICE9 dev)
			{
				shader_base::setup(dev);
				HRESULT hr=S_OK;
				hr=constant_table->SetFloatArray(dev,c1_handle,c1,4);
				assert(SUCCEEDED(hr));
			}
		};

		struct shader_I2_C2 : public shader_base
		{
			D3DXHANDLE			i1_handle;
			D3DXHANDLE			i2_handle;
			D3DXHANDLE			c1_handle;
			D3DXHANDLE			c2_handle;

			float				i1;
			float				i2;
			float				c1[4];
			float				c2[4];

			bool init(const TCHAR *shader_file,
				LPDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				if(!shader_base::init(shader_file,dev,profile))
				{
					return false;
				}
				//i1
				i1_handle=NULL;
				i1_handle=constant_table->GetConstantByName(NULL,"i1");
				assert(i1_handle);
				//i2
				i2_handle=NULL;
				i2_handle=constant_table->GetConstantByName(NULL,"i2");
				assert(i2_handle);
				//c1
				c1_handle=NULL;
				c1_handle=constant_table->GetConstantByName(NULL,"c1");
				assert(c1_handle);
				//c2
				c2_handle=NULL;
				c2_handle=constant_table->GetConstantByName(NULL,"c2");
				assert(c2_handle);
				return true;
			}
			void setup(PDIRECT3DDEVICE9 dev)
			{
				shader_base::setup(dev);
				HRESULT hr=S_OK;
				hr=constant_table->SetFloat(dev,i1_handle,i1);
				assert(SUCCEEDED(hr));
				hr=constant_table->SetFloat(dev,i2_handle,i2);
				assert(SUCCEEDED(hr));
				hr=constant_table->SetFloatArray(dev,c1_handle,c1,4);
				assert(SUCCEEDED(hr));
				hr=constant_table->SetFloatArray(dev,c2_handle,c2,4);
				assert(SUCCEEDED(hr));
			}
		};

		struct shader_F1 : public shader_base
		{
			D3DXHANDLE			f1_handle;

			float				f1;

			bool init(const TCHAR *shader_file,
				LPDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				if(!shader_base::init(shader_file,dev,profile))
				{
					return false;
				}
				//f1
				f1_handle=NULL;
				f1_handle=constant_table->GetConstantByName(NULL,"f1");
				assert(f1_handle);
				return true;
			}
			void setup(PDIRECT3DDEVICE9 dev)
			{
				shader_base::setup(dev);
				HRESULT hr=S_OK;
				hr=constant_table->SetFloat(dev,f1_handle,f1);
				assert(SUCCEEDED(hr));
			}
		};

		struct shader_F2 : public shader_F1
		{
			D3DXHANDLE			f2_handle;

			float				f2;

			bool init(const TCHAR *shader_file,
				LPDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				if(!shader_F1::init(shader_file,dev,profile))
				{
					return false;
				}
				//f2
				f2_handle=NULL;
				f2_handle=constant_table->GetConstantByName(NULL,"f2");
				assert(f2_handle);
				return true;
			}
			void setup(PDIRECT3DDEVICE9 dev)
			{
				shader_F1::setup(dev);
				HRESULT hr=S_OK;
				hr=constant_table->SetFloat(dev,f2_handle,f2);
				assert(SUCCEEDED(hr));
			}
		};

		struct shader_F2_I : public shader_F2
		{
			D3DXHANDLE			i1_handle;

			float				i1;

			bool init(const TCHAR *shader_file,
				LPDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				if(!shader_F2::init(shader_file,dev,profile))
				{
					return false;
				}
				//i1
				i1_handle=NULL;
				i1_handle=constant_table->GetConstantByName(NULL,"i1");
				assert(i1_handle);
				return true;
			}
			void setup(PDIRECT3DDEVICE9 dev)
			{
				shader_F2::setup(dev);
				HRESULT hr=S_OK;
				hr=constant_table->SetFloat(dev,i1_handle,i1);
				assert(SUCCEEDED(hr));
			}
		};

		struct shader_F3 : public shader_F2
		{
			D3DXHANDLE			f3_handle;

			float				f3;

			bool init(const TCHAR *shader_file,
				LPDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				if(!shader_F2::init(shader_file,dev,profile))
				{
					return false;
				}
				//f3
				f3_handle=NULL;
				f3_handle=constant_table->GetConstantByName(NULL,"f3");
				assert(f3_handle);
				return true;
			}
			void setup(PDIRECT3DDEVICE9 dev)
			{
				shader_F2::setup(dev);
				HRESULT hr=S_OK;
				hr=constant_table->SetFloat(dev,f3_handle,f3);
				assert(SUCCEEDED(hr));
			}
		};

		struct shader_F2_C2 : public shader_F2
		{
			D3DXHANDLE			c1_handle;
			D3DXHANDLE			c2_handle;

			float				c1[4];
			float				c2[4];

			bool init(const TCHAR *shader_file,
				LPDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				if(!shader_F2::init(shader_file,dev,profile))
				{
					return false;
				}
				//c1
				c1_handle=NULL;
				c1_handle=constant_table->GetConstantByName(NULL,"c1");
				assert(c1_handle);
				//c2
				c2_handle=NULL;
				c2_handle=constant_table->GetConstantByName(NULL,"c2");
				assert(c2_handle);
				return true;
			}
			void setup(PDIRECT3DDEVICE9 dev)
			{
				shader_F2::setup(dev);
				HRESULT hr=S_OK;
				hr=constant_table->SetFloatArray(dev,c1_handle,c1,4);
				assert(SUCCEEDED(hr));
				hr=constant_table->SetFloatArray(dev,c2_handle,c2,4);
				assert(SUCCEEDED(hr));
			}
		};

		struct shader_F3_C2 : public shader_F2_C2
		{
			D3DXHANDLE			f3_handle;

			float				f3;

			bool init(const TCHAR *shader_file,
				LPDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				if(!shader_F2_C2::init(shader_file,dev,profile))
				{
					return false;
				}
				//f3
				f3_handle=NULL;
				f3_handle=constant_table->GetConstantByName(NULL,"f3");
				assert(f3_handle);
				return true;
			}
			void setup(PDIRECT3DDEVICE9 dev)
			{
				shader_F2_C2::setup(dev);
				HRESULT hr=S_OK;
				hr=constant_table->SetFloat(dev,f3_handle,f3);
				assert(SUCCEEDED(hr));
			}
		};

		struct shader_checkers_aa : public shader_I2_C2
		{
			D3DXHANDLE			pixel_size_handle;
			D3DXHANDLE			pixel_area_inv_handle;

			float				pixel_size[4];
			float				pixel_area_inv;

			bool init(const TCHAR *shader_file,
				LPDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				if(!shader_I2_C2::init(shader_file,dev,profile))
				{
					return false;
				}
				//pixel_size
				pixel_size_handle=NULL;
				pixel_size_handle=constant_table->
					GetConstantByName(NULL,"pixel_size");
				assert(pixel_size_handle);
				//pixel_area_inv
				pixel_area_inv_handle=NULL;
				pixel_area_inv_handle=constant_table->
					GetConstantByName(NULL,"pixel_area_inv");
				assert(pixel_area_inv_handle);
				return true;
			}
			void setup(PDIRECT3DDEVICE9 dev)
			{
				shader_I2_C2::setup(dev);
				HRESULT hr=S_OK;
				hr=constant_table->
					SetFloatArray(dev,pixel_size_handle,pixel_size,4);
				assert(SUCCEEDED(hr));
				hr=constant_table->
					SetFloat(dev,pixel_area_inv_handle,pixel_area_inv);
				assert(SUCCEEDED(hr));
			}
		};

		struct shader_wave : public shader_F2_I
		{
			D3DXHANDLE			shading_space_offset_handle;

			float				shading_space_offset[2];

			bool init(const TCHAR *shader_file,
				LPDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				if(!shader_F2_I::init(shader_file,dev,profile))
				{
					return false;
				}
				shading_space_offset_handle=NULL;
				shading_space_offset_handle=constant_table->
					GetConstantByName(NULL,"shading_space_offset");
				assert(shading_space_offset_handle);
				return true;
			}
			void setup(PDIRECT3DDEVICE9 dev)
			{
				shader_F2_I::setup(dev);
				HRESULT hr=S_OK;
				hr=constant_table->
					SetFloatArray(dev,shading_space_offset_handle,shading_space_offset,2);
				assert(SUCCEEDED(hr));
			}
		};

		struct shader_wave_bicubic : public shader_wave
		{
			D3DXHANDLE			tx_sizes_handle;

			float				tx_sizes[4];

			bool init(const TCHAR *shader_file,
				LPDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				if(!shader_wave::init(shader_file,dev,profile))
				{
					return false;
				}
				tx_sizes_handle=NULL;
				tx_sizes_handle=constant_table->
					GetConstantByName(NULL,"tx_sizes");
				assert(tx_sizes_handle);
				return true;
			}
			void setup(PDIRECT3DDEVICE9 dev)
			{
				shader_wave::setup(dev);
				HRESULT hr=S_OK;
				hr=constant_table->
					SetFloatArray(dev,tx_sizes_handle,tx_sizes,4);
				assert(SUCCEEDED(hr));
			}
		};

		struct shader_F2_bicubic : public shader_F2
		{
			D3DXHANDLE			tx_sizes_handle;

			float				tx_sizes[4];

			bool init(const TCHAR *shader_file,
				LPDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				if(!shader_F2::init(shader_file,dev,profile))
				{
					return false;
				}
				tx_sizes_handle=NULL;
				tx_sizes_handle=constant_table->
					GetConstantByName(NULL,"tx_sizes");
				assert(tx_sizes_handle);
				return true;
			}
			void setup(PDIRECT3DDEVICE9 dev)
			{
				shader_F2::setup(dev);
				HRESULT hr=S_OK;
				hr=constant_table->
					SetFloatArray(dev,tx_sizes_handle,tx_sizes,4);
				assert(SUCCEEDED(hr));
			}
		};

		struct shader_noise_octave : public shader_base
		{
			D3DXHANDLE			shading_space_offset_handle;
			D3DXHANDLE			noise_offset_handle;
			D3DXHANDLE			noise_factor_handle;
			D3DXHANDLE			noise_scale_handle;
			D3DXHANDLE			octave_scale_handle;
			D3DXHANDLE			octave_weight_handle;

			float				shading_space_offset[2];
			//float				noise_offset;
			//float				noise_factor;
			float				noise_scale;
			float				octave_scale;
			float				octave_weight;

			PDIRECT3DTEXTURE9	noise_perm_tbl;
			PDIRECT3DTEXTURE9	noise_grad_tbl;

			bool init(const TCHAR *shader_file,
				LPDIRECT3DDEVICE9 dev,
				LPCSTR profile)
			{
				if(!shader_base::init(shader_file,dev,profile))
				{
					return false;
				}
				shading_space_offset_handle=NULL;
				shading_space_offset_handle=constant_table->
					GetConstantByName(NULL,"shading_space_offset");
				assert(shading_space_offset_handle);
				assert(noise_factor_handle);
				noise_scale_handle=NULL;
				noise_scale_handle=constant_table->
					GetConstantByName(NULL,"noise_scale");
				assert(noise_scale_handle);
				octave_scale_handle=NULL;
				octave_scale_handle=constant_table->
					GetConstantByName(NULL,"octave_scale");
				assert(octave_scale_handle);
				octave_weight_handle=NULL;
				octave_weight_handle=constant_table->
					GetConstantByName(NULL,"octave_weight");
				assert(octave_weight_handle);
				noise_perm_tbl=NULL;
				noise_grad_tbl=NULL;
				return true;
			}

			void setup(PDIRECT3DDEVICE9 dev)
			{
				shader_base::setup(dev);
				HRESULT hr=S_OK;
				hr=constant_table->
					SetFloatArray(dev,shading_space_offset_handle,shading_space_offset,2);
				assert(SUCCEEDED(hr));
				hr=constant_table->
					SetFloat(dev,noise_scale_handle,noise_scale);
				assert(SUCCEEDED(hr));
				hr=constant_table->
					SetFloat(dev,octave_scale_handle,octave_scale);
				assert(SUCCEEDED(hr));
				hr=constant_table->
					SetFloat(dev,octave_weight_handle,octave_weight);
				assert(SUCCEEDED(hr));
			}

			void release()
			{
				shader_base::release();
				if(noise_perm_tbl)
				{
					noise_perm_tbl->Release();
					noise_perm_tbl=NULL;
				}
				if(noise_grad_tbl)
				{
					noise_grad_tbl->Release();
					noise_grad_tbl=NULL;
				}
			}

			void init_noise_tables(PDIRECT3DDEVICE9 dev)
			{
				if(!noise_perm_tbl)
				{
					//create lookup textures
					HRESULT hr=dev->CreateTexture(64,1,1,0,D3DFMT_L8,D3DPOOL_MANAGED,&noise_perm_tbl,NULL);
					assert(SUCCEEDED(hr));
					hr=dev->CreateTexture(64,1,1,0,D3DFMT_G32R32F,D3DPOOL_MANAGED,&noise_grad_tbl,NULL);
					assert(SUCCEEDED(hr));
				}
				unsigned char tmp_noise_perm_tbl[64];
				float tmp_noise_grad_tbl[128];

				//initialize the permutation table
				int i=0;
				int j=0;
				int k=0;
				for(i=0;i<64;i++)
				{
					tmp_noise_perm_tbl[i]=(unsigned char)i;
				}
				for(i=0;i<32;i++)
				{
					int t=0;
					j=rand()&63;
					k=rand()&63;
					t=tmp_noise_perm_tbl[j];
					tmp_noise_perm_tbl[j]=tmp_noise_perm_tbl[k];
					tmp_noise_perm_tbl[k]=(unsigned char)t;
				}

				for(i=0;i<64;i++)
				{
					tmp_noise_perm_tbl[i]*=4;
				}
			  
				//initialize the gradient table
				for(i=0;i<64;i++)
				{
					float m=0.0f;
					do
					{
						tmp_noise_grad_tbl[2*i]=(float)(rand()-(RAND_MAX>>1))/(RAND_MAX>>1);
						tmp_noise_grad_tbl[2*i+1]=(float)(rand()-(RAND_MAX>>1))/(RAND_MAX>>1);
						m=tmp_noise_grad_tbl[2*i]*tmp_noise_grad_tbl[2*i]+tmp_noise_grad_tbl[2*i+1]*tmp_noise_grad_tbl[2*i+1];
					}
					while((m==0.0f) || (m>1.0f));

					m=1.0f/sqrtf(m);
					tmp_noise_grad_tbl[2*i]*=m;
					tmp_noise_grad_tbl[2*i+1]*=m;
				}

				//update textures
				D3DLOCKED_RECT lr;
				HRESULT hr=noise_perm_tbl->LockRect(0,&lr,NULL,0);
				assert(SUCCEEDED(hr));
				memcpy(lr.pBits,tmp_noise_perm_tbl,64);
				hr=noise_perm_tbl->UnlockRect(0);
				assert(SUCCEEDED(hr));

				hr=noise_grad_tbl->LockRect(0,&lr,NULL,0);
				assert(SUCCEEDED(hr));
				memcpy(lr.pBits,tmp_noise_grad_tbl,128*sizeof(float));
				hr=noise_grad_tbl->UnlockRect(0);
				assert(SUCCEEDED(hr));
			}
		};

	}

	typedef std::map<LayerDesc,
		NIMPLibHwInternal::LayerProxy,layer_less>	io_proxy_map_t;

	class ExecutionEngineHw : public ExecutionEngine
	{
		PDIRECT3DDEVICE9						device;
		PDIRECT3DVERTEXDECLARATION9				vertex_decl;
		std::vector<NIMPLibHwInternal::Layer>	layers;
		//input/output proxies
		io_proxy_map_t							io_proxy_map;
		//swizzle buffer - we need only one (that fits largest layer created)
		void									*swizzle_buffer;
		size_t									swizzle_buffer_size;
		EError getLayerByteSize(LayerDesc &desc,DWORD &dwByteSize);
		//vertex buffer - DrawPrimitiveUP is nasty but here it doesn't matter :)
		//vertex is 6 floats, 4 vertices gives us 24 floats
		float									vb[24];
		void prepare_vb(unsigned int rt_size_x,unsigned int rt_size_y);
		void set_render_target(unsigned char ucLayer);
		void set_texture(unsigned char stage,unsigned char ucLayer,bool bFilter=false);
		void set_texture(unsigned char stage,PDIRECT3DTEXTURE9 tx,bool bFilter=false);
		void draw();
		//shaders
		NIMPLibHwInternal::shader_checkers_aa	s_checkers_aa;
		NIMPLibHwInternal::shader_base			s_add;
		NIMPLibHwInternal::shader_base			s_sub;
		NIMPLibHwInternal::shader_base			s_mul;
		NIMPLibHwInternal::shader_base			s_signed_add;
		NIMPLibHwInternal::shader_C1			s_add_color;
		NIMPLibHwInternal::shader_C1			s_sub_color;
		NIMPLibHwInternal::shader_C1			s_mul_color;
		NIMPLibHwInternal::shader_F3_C2			s_rgradient_c;
		NIMPLibHwInternal::shader_F3_C2			s_rgradient_c_cubic;
		NIMPLibHwInternal::shader_F3_C2			s_rgradient_c_sin;
		NIMPLibHwInternal::shader_F3_C2			s_rgradient_e;
		NIMPLibHwInternal::shader_F3_C2			s_rgradient_e_sin;
		NIMPLibHwInternal::shader_wave			s_wave_x;
		NIMPLibHwInternal::shader_wave			s_wave_y;
		NIMPLibHwInternal::shader_wave			s_lwave_x;
		NIMPLibHwInternal::shader_wave			s_lwave_y;
		NIMPLibHwInternal::shader_wave_bicubic	s_wave_x_bicubic;
		NIMPLibHwInternal::shader_wave_bicubic	s_wave_y_bicubic;
		NIMPLibHwInternal::shader_wave_bicubic	s_lwave_x_bicubic;
		NIMPLibHwInternal::shader_wave_bicubic	s_lwave_y_bicubic;
		NIMPLibHwInternal::shader_wave			s_wave_x_vf;
		NIMPLibHwInternal::shader_wave			s_wave_y_vf;
		NIMPLibHwInternal::shader_wave			s_lwave_x_vf;
		NIMPLibHwInternal::shader_wave			s_lwave_y_vf;
		NIMPLibHwInternal::shader_F2			s_vf_distort;
		NIMPLibHwInternal::shader_F2_bicubic	s_vf_distort_bicubic;
		//we allocate three F32 layers (if needed)
		UCHAR									first_r32f_layer;
		NIMPLibHwInternal::shader_noise_octave	s_noise_1_octave;
		NIMPLibHwInternal::shader_noise_octave	s_noise_2_octaves;
		NIMPLibHwInternal::shader_noise_octave	s_noise_3_octaves;
		NIMPLibHwInternal::shader_noise_octave	s_noise_4_octaves;
		NIMPLibHwInternal::shader_F2_C2			s_noise_final_remap;
		NIMPLibHwInternal::shader_noise_octave	s_turbulence_1_octave;
		NIMPLibHwInternal::shader_noise_octave	s_turbulence_2_octaves;
		NIMPLibHwInternal::shader_noise_octave	s_turbulence_3_octaves;
		NIMPLibHwInternal::shader_noise_octave	s_turbulence_4_octaves;
		NIMPLibHwInternal::shader_F3			s_hsv_adjust;
		NIMPLibHwInternal::shader_base			s_grayscale;
		NIMPLibHwInternal::shader_F1			s_sobel_edge_detect;
	public:
		ExecutionEngineHw();
		~ExecutionEngineHw();
		bool isLayerFormatSupported(ELayerFormat format);
		EError setLayerFormat(ELayerFormat format);
		bool layersMustBePow2Sized();
		EError allocateLayers(LayerDesc &desc,DWORD dwCount);
		void freeLayers();
		EError getLayerDesc(UCHAR ucLayerID,LayerDesc &desc);
		EError loadLayerData(UCHAR ucLayerID,DWORD dwByteCount,const void *pData);
		EError getLayerData(UCHAR ucLayerID,DWORD dwByteCount,void *pData);
		EError loadLayerFromPNGFile(UCHAR ucLayerID,const TCHAR *pszFileName,
			data_ready_callback_t dr);
		EError saveLayerToPNGFile(UCHAR ucLayerID,const TCHAR *pszFileName,
			data_ready_callback_t dr);
		EError init(PDIRECT3DDEVICE9 dev);
		//operations
		EError add(UCHAR ucLayer1,UCHAR ucLayer2,UCHAR ucLayer3);
		EError add_color(UCHAR ucLayer1,UCHAR ucLayer2,float color[4]);
		EError sub(UCHAR ucLayer1,UCHAR ucLayer2,UCHAR ucLayer3);
		EError sub_color(UCHAR ucLayer1,UCHAR ucLayer2,float color[4]);
		EError mul(UCHAR ucLayer1,UCHAR ucLayer2,UCHAR ucLayer3);
		EError mul_color(UCHAR ucLayer1,UCHAR ucLayer2,float color[4]);
		EError signed_add(UCHAR ucLayer1,UCHAR ucLayer2,UCHAR ucLayer3);

		EError checkers_aa(UCHAR ucLayer1,int divisions_x,int divisions_y,
			float color_odd[4],float color_even[4]);
		EError rgradient_c(UCHAR ucLayer1,float center_x,float center_y,
			float radius,float color_inner[4],float color_outer[4]);
		EError rgradient_c_cubic(UCHAR ucLayer1,float center_x,float center_y,
			float radius,float color_inner[4],float color_outer[4]);
		EError rgradient_c_sin(UCHAR ucLayer1,float center_x,float center_y,
			float radius,float color_inner[4],float color_outer[4]);
		EError rgradient_e(UCHAR ucLayer1,float center_x,float center_y,
			float radius,float color_inner[4],float color_outer[4]);
		EError rgradient_e_sin(UCHAR ucLayer1,float center_x,float center_y,
			float radius,float color_inner[4],float color_outer[4]);
		EError noise(UCHAR ucLayer1,int noise_scale,int seed,int octaves,
			float color1[4],float color2[4]);
		EError turbulence(UCHAR ucLayer1,int noise_scale,int seed,
			int octaves,float color1[4],float color2[4]);

		EError wave_x(UCHAR ucLayer1,UCHAR ucLayer2,float amplitude,
			float phase,int nwaves);
		EError wave_x_bicubic(UCHAR ucLayer1,UCHAR ucLayer2,float amplitude,
			float phase,int nwaves);
		EError lwave_x(UCHAR ucLayer1,UCHAR ucLayer2,float amplitude,
			float phase,int nwaves);
		EError lwave_x_bicubic(UCHAR ucLayer1,UCHAR ucLayer2,float amplitude,
			float phase,int nwaves);
		EError wave_y(UCHAR ucLayer1,UCHAR ucLayer2,float amplitude,
			float phase,int nwaves);
		EError wave_y_bicubic(UCHAR ucLayer1,UCHAR ucLayer2,float amplitude,
			float phase,int nwaves);
		EError lwave_y(UCHAR ucLayer1,UCHAR ucLayer2,float amplitude,
			float phase,int nwaves);
		EError lwave_y_bicubic(UCHAR ucLayer1,UCHAR ucLayer2,float amplitude,
			float phase,int nwaves);
		EError vf_distort(UCHAR ucLayer1,UCHAR ucLayer2,UCHAR ucLayer3,
			float scale_x,float scale_y);
		EError vf_distort_bicubic(UCHAR ucLayer1,UCHAR ucLayer2,UCHAR ucLayer3,
			float scale_x,float scale_y);

		EError wave_x_vf(UCHAR ucLayer1,float amplitude,float phase,int nwaves);
		EError lwave_x_vf(UCHAR ucLayer1,float amplitude,float phase,int nwaves);
		EError wave_y_vf(UCHAR ucLayer1,float amplitude,float phase,int nwaves);
		EError lwave_y_vf(UCHAR ucLayer1,float amplitude,float phase,int nwaves);

		EError hsv_adjust(UCHAR ucLayer1,UCHAR ucLayer2,float h_rotation_deg,
			float s_offset,float v_offset);
		EError grayscale(UCHAR ucLayer1,UCHAR ucLayer2);

		EError sobel_edge_detect(UCHAR ucLayer1,UCHAR ucLayer2,float sample_spacing);
	};
};

#endif